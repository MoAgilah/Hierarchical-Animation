#include "Hierarchy.h"
#include <algorithm>
#include <fstream>
#include <sstream> 

XMVECTOR SmoothStep(XMVECTOR V0, XMVECTOR V1, float t)
{
	t = (t > 1.0f) ? 1.0f : ((t < 0.0f) ? 0.0f : t);  // Clamp value to 0 to 1
	t = t*t*(3.f - 2.f*t);
	return XMVectorLerp(V0, V1, t);
}


bool isUneeded(char c)
{
	return (c == '\"' || c == ',');
}

MeshComponent* Hiearchy::s_Root = nullptr;
map<string, MeshComponent*> Hiearchy::hierachie;
map<string, Animation*> Hiearchy::animations;

Hiearchy::Hiearchy(string fN, string hfN, XMFLOAT3 p, XMFLOAT3 r, double s)
	:fName(fN),hfName(hfN), iP(p), iR(r), sF(s)
{
	Root = "";
	timer = 0;
	stride = 0;
	hasAnim = false;
}

Hiearchy::~Hiearchy()
{
	delete s_Root;
}

MeshComponent* Hiearchy::GetByName(const string& name)
{
	return hierachie.find(name)->second;
}

MeshComponent* Hiearchy::GetRoot()
{
	return GetByName(Root);
}

void Hiearchy::LoadFromFile()
{
	string line;
	vector<string> l;
	float pX, pY, pZ;
	ifstream in;
	string path = "Resources/" + fName + "/" + hfName;
	in.open(path, fstream::out);

	while (getline(in, line)){
		line.erase(remove_if(line.begin(), line.end(), isUneeded), line.end());
		l.push_back(line);
	}

	Root = l[0];
	stringstream pos(l[2]);
	pos >> pX;	pos >> pY;	pos >> pZ;
	pX /= sF; pY /= sF; pZ /= sF;

	s_Root = new MeshComponent(XMFLOAT3(pX + iP.x, pY + iP.y, pZ + iP.z), XMFLOAT3(iR.x, iR.y, iR.z), fName, l[0]);
	hierachie.insert(std::pair<string, MeshComponent*>(l[0], s_Root));

	for (int i = 3; i < l.size(); i += 3)
	{
		stringstream pos(l[i + 2]);
		pos >> pX;	pos >> pY;	pos >> pZ;
		pX /= sF; pY /= sF; pZ /= sF;
		hierachie.insert(std::pair<string, MeshComponent*>(l[i], new MeshComponent(XMFLOAT3(pX, pY, pZ), XMFLOAT3(0, 0, 0), fName, l[i])));
	}

	for (int i = 3; i < l.size(); i += 3)
	{
		if (l[i + 1] != "")
		{
			GetByName(l[i + 1])->AddChild(GetByName(l[i]));
		}
	}

	in.close();
}

void Hiearchy::LoadAnimation(const string& aName)
{
	animations.insert(std::pair<string, Animation*>(aName, new Animation(fName, aName, sF)));
	if (!GetRoot()->GetHasAnim())GetRoot()->SetHasAnim();
}

void Hiearchy::Animate(const float& time)
{
	timer += time;

	XMFLOAT4 trans, rot;
	
	for (int i = 0; i < GetClipByName("Attack")->ani.size(); i += 4)
	{
		if (timer <= GetClipByName("Attack")->keyframes.front())
		{
			if (GetClipByName("Attack")->ani[i].name == "root")
			{
				trans = XMFLOAT4(*GetClipByName("Attack")->ani[i].val.begin() + iP.x,
					*(GetClipByName("Attack")->ani[i].val.begin() + 1) + iP.y,
					*(GetClipByName("Attack")->ani[i].val.begin() + 2) + iP.z, 0);
				GetByName(GetClipByName("Attack")->ani[i].name)->GetLocPos() = trans;
			}
			else
			{
				trans = XMFLOAT4(*GetClipByName("Attack")->ani[i].val.begin(),
					*(GetClipByName("Attack")->ani[i].val.begin() + 1),
					*(GetClipByName("Attack")->ani[i].val.begin() + 2), 0);
				GetByName(GetClipByName("Attack")->ani[i].name)->GetLocPos() = trans;
			}

			rot = XMFLOAT4(GetClipByName("Attack")->ani[i + 1].val.front(),
				GetClipByName("Attack")->ani[i + 2].val.front(),
				GetClipByName("Attack")->ani[i + 3].val.front(), 0);
			GetByName(GetClipByName("Attack")->ani[i + 1].name)->GetLocRot() = rot;
		}
		else if (timer >= GetClipByName("Attack")->keyframes.back())
		{
			if (GetClipByName("Attack")->ani[i].name == "root")
			{
				trans = XMFLOAT4(*(GetClipByName("Attack")->ani[i].val.end() - 3) + iP.x,
					*(GetClipByName("Attack")->ani[i].val.end() - 2) + iP.y,
					*(GetClipByName("Attack")->ani[i].val.end() - 1) + iP.z, 0);
				GetByName(GetClipByName("Attack")->ani[i].name)->GetLocPos() = trans;
			}
			else
			{
				trans = XMFLOAT4(*(GetClipByName("Attack")->ani[i].val.end() - 3),
					*(GetClipByName("Attack")->ani[i].val.end() - 2),
					*(GetClipByName("Attack")->ani[i].val.end() - 1), 0);
				GetByName(GetClipByName("Attack")->ani[i].name)->GetLocPos() = trans;
			}

			rot = XMFLOAT4(GetClipByName("Attack")->ani[i + 1].val.back(),
				GetClipByName("Attack")->ani[i + 2].val.back(),
				GetClipByName("Attack")->ani[i + 3].val.back(), 0);
			GetByName(GetClipByName("Attack")->ani[i + 1].name)->GetLocRot() = rot;

			timer = 0;
		}
		else
		{
			for (int j = 0; j < GetClipByName("Attack")->keyframes.size() - 1; ++j)
			{
				if (timer >= GetClipByName("Attack")->keyframes[j] && timer <= GetClipByName("Attack")->keyframes[j + 1])
				{
					float lerpPercent = (timer - GetClipByName("Attack")->keyframes[j]) /
						(GetClipByName("Attack")->keyframes[j + 1] - GetClipByName("Attack")->keyframes[j]);

					XMVECTOR t1, t2, r1, r2, ft, fr;

					stride = GetClipByName("Attack")->ani[i].val.size() / GetClipByName("Attack")->ani[i].stride;
					
					if (stride > 1)
					{
						int f = (j * stride);
						int s = ((j+1) * stride);
						
						if (GetClipByName("Attack")->ani[i].name == "root")
						{
							trans = XMFLOAT4(GetClipByName("Attack")->ani[i].val[f] + iP.x,
								GetClipByName("Attack")->ani[i].val[f+1] + iP.y,
								GetClipByName("Attack")->ani[i].val[f+2] + iP.z, 0);
						}
						else
						{
							trans = XMFLOAT4(GetClipByName("Attack")->ani[i].val[f],
								GetClipByName("Attack")->ani[i].val[f+1],
								GetClipByName("Attack")->ani[i].val[f+2], 0);
						}

						t1 = XMLoadFloat4(&trans);
						
						if (GetClipByName("Attack")->ani[i].name == "root")
						{
						trans = XMFLOAT4(GetClipByName("Attack")->ani[i].val[s] + iP.x,
						GetClipByName("Attack")->ani[i].val[s+1] + iP.y,
						GetClipByName("Attack")->ani[i].val[s+2] + iP.z, 0);
						}
						else
						{
						trans = XMFLOAT4(GetClipByName("Attack")->ani[i].val[s],
						GetClipByName("Attack")->ani[i].val[s+1],
						GetClipByName("Attack")->ani[i].val[s+2], 0);
						}

						t2 = XMLoadFloat4(&trans);
					
						ft = SmoothStep(t1, t2, lerpPercent);
						XMVector4Normalize(ft);

						XMStoreFloat4(&trans, ft);
						
						GetByName(GetClipByName("Attack")->ani[i].name)->GetLocPos() = trans;
					}

					rot = XMFLOAT4(GetClipByName("Attack")->ani[i + 1].val[j],
						GetClipByName("Attack")->ani[i + 2].val[j],
						GetClipByName("Attack")->ani[i + 3].val[j], 0);

					r1 = XMLoadFloat4(&rot);

					rot = XMFLOAT4(GetClipByName("Attack")->ani[i + 1].val[j+1],
						GetClipByName("Attack")->ani[i + 2].val[j+1],
						GetClipByName("Attack")->ani[i + 3].val[j+1], 0);
					
					r2 = XMLoadFloat4(&rot);

					fr = SmoothStep(r1, r2, lerpPercent);
					XMStoreFloat4(&rot, fr);
					
					GetByName(GetClipByName("Attack")->ani[i + 1].name)->GetLocRot() = rot;

					break;
				}
			}
		}
	}
}

Animation*  Hiearchy::GetClipByName(const string& name)
{
	return animations.find(name)->second;
}

void Hiearchy::Draw()
{
	s_Root->Draw();
}