#include "Bullet.h"

Bullet::Bullet(CommonMesh* Bullet)
{
	p_active = false;

	m_mWorldMatrix = XMMatrixIdentity();

	p_Bullet = Bullet;

	m_fSpeed = 2.0f;
}

Bullet::~Bullet()
{
	delete p_Bullet;
}

void Bullet::Activate(const XMMATRIX& gunMatrix, const float& iVel)
{
	//initial velocity
	m_fSpeed = iVel;
	//then can use suvat to update properly in update

	//could be useful
	//XMMatrixDecompose()

	//pos
	XMStoreFloat4(&m_v4Pos, gunMatrix.r[3]);

	//forwardVector
	m_vForwardVector = gunMatrix.r[2];

	//either use this or
	m_mWorldMatrix = gunMatrix;

	//or this when figured out how to get the rot out of top three rows
	m_mWorldMatrix = XMMatrixIdentity();
}

void Bullet::Activate(const XMFLOAT4& pos, const XMFLOAT4& rot, const XMVECTOR& fVec)
{
	p_active = true;

	m_mWorldMatrix = XMMatrixIdentity();
	m_v4Rot = rot;
	m_v4Pos = pos;

	m_vForwardVector = fVec;

	timer = 0;
}

Bullet* Bullet::getNext() const 
{ 
 	return next;
}

void Bullet::setNext(Bullet* n) 
{ 
	next = n;
}

bool Bullet::GetActive()
{
	return p_active;
}

void Bullet::Deactivate()
{
	p_active  = false;
}

bool Bullet::Update(const float& dt)
{
    timer += dt;
	
	// Move Forward
	XMVECTOR vCurrPos = XMLoadFloat4(&m_v4Pos);
	vCurrPos += m_vForwardVector * m_fSpeed;
	XMStoreFloat4(&m_v4Pos, vCurrPos);
	UpdateMatrices();

	return timer >= 5;
}

void Bullet::Draw(void)
{
	Application::s_pApp->SetWorldMatrix(m_mWorldMatrix);
	p_Bullet->Draw();
}

void Bullet::UpdateMatrices(void)
{
	XMVECTOR pVec;
	XMMATRIX mScale, mRotX, mRotY, mRotZ, mTrans;

	mScale = XMMatrixScaling(0.1, 0.1, 0.1);

	mRotX = XMMatrixRotationX(XMConvertToRadians(m_v4Rot.x));
	mRotY = XMMatrixRotationY(XMConvertToRadians(m_v4Rot.y));
	mRotZ = XMMatrixRotationZ(XMConvertToRadians(m_v4Rot.z));

	pVec = XMLoadFloat4(&m_v4Pos);
	mTrans = XMMatrixTranslationFromVector(pVec);

	m_mWorldMatrix = mScale * mRotX *	mRotY *	mRotZ * mTrans;

	//m_mWorldMatrix = mScale * mRotX * mRotZ * mRotY * mTrans;
}