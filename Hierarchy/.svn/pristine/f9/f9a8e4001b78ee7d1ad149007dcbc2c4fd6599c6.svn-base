#include "Bullet.h"

Bullet::Bullet(CommonMesh* Bullet)
{
	p_active = false;

	m_mWorldMatrix = XMMatrixIdentity();

	p_Bullet = Bullet;

	m_fSpeed = 2.0f;
}

Bullet::~Bullet()
{
	delete p_Bullet;
}

void Bullet::Activate(const XMFLOAT4& pos, const XMFLOAT4& rot, const XMVECTOR& fVec)
{
	p_active = true;

	m_mWorldMatrix = XMMatrixIdentity();
	m_v4Rot = rot;
	m_v4Pos = pos;

	m_vForwardVector = fVec;

	timer = 0;
}

Bullet* Bullet::getNext() const 
{ 
	return next;
}

void Bullet::setNext(Bullet* n) 
{ 
	next = n;
}

bool Bullet::GetActive()
{
	return p_active;
}

void Bullet::Deactivate()
{
	p_active  = false;
}

bool Bullet::Update(const float& dt)
{
	timer += 0.1f * dt;
	
	// Move Forward
	XMVECTOR vCurrPos = XMLoadFloat4(&m_v4Pos);
	vCurrPos += m_vForwardVector * (m_fSpeed  * dt);
	XMStoreFloat4(&m_v4Pos, vCurrPos);
	UpdateMatrices();

	return timer > 20;
}

void Bullet::Draw(void)
{
	Application::s_pApp->SetWorldMatrix(m_mWorldMatrix);
	p_Bullet->Draw();
}

void Bullet::UpdateMatrices(void)
{
	XMVECTOR pVec;
	XMMATRIX mScale, mRotX, mRotY, mRotZ, mTrans;

	mScale = XMMatrixScaling(0.1, 0.1, 0.1);

	mRotX = XMMatrixRotationX(XMConvertToRadians(m_v4Rot.x));
	mRotY = XMMatrixRotationY(XMConvertToRadians(m_v4Rot.y));
	mRotZ = XMMatrixRotationZ(XMConvertToRadians(m_v4Rot.z));

	pVec = XMLoadFloat4(&m_v4Pos);
	mTrans = XMMatrixTranslationFromVector(pVec);

	m_mWorldMatrix = mScale * mRotX *	mRotY *	mRotZ * mTrans;

	//m_mWorldMatrix = mScale * mRotX * mRotZ * mRotY * mTrans;
}